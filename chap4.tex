%%% -*-LaTeX-*-

\chapter{SweetPea Language}

The goal of the SweetPea language is to have semantics that match the terms researchers use to describe their experiments, while also being amenable to being translated efficiently to SAT.

- summary here

TODO: everytime I saw "sometimes" come up with an example.

\section{Components of an Experiment}

We briefly saw the parts of an experiment with the Stroop test in Chapter 2. Now let's look at the range of experiments we wish to model, and how our representations of these experiments are amenable to SAT.

\subsection{Descriptions of Stimuli}

TODO diagrams

Each component of a stimuli is represented as a \emph{factor} which can take on a disrete number of \emph{levels}. In the Stroop experiment this was represented as the ink color being red of blue, and the text color being red or blue.

Experiments typically have 2 to 7 factors with 2 to 4 levels each, resulting in roughly 50 to 200 stimuli. Often the ideal goal is to \emph{fully cross} all of the factors to produce all possible combinations of stimuli, but sometimes factors are left out of the full crossing. For example, a subject can only reliably be tested for so long before they are tired, so sometimes factors which are deemed to be irrelevant to the control variables and variables of interest are excluded from the full crossing.

Levels may be nested into sub-levels. One reason to want to do this is to apply different constraints to each of the sublevels. For instance, a color factor may have nested sublevels of light colors (like yellow and pink) and dark colors (like navy and maroon).

Sometimes researchers may want to define factors with levels sampled from a continuous distribution, for example to model a spectrum of light or sound. Sweetpea currently does not support this other than by the research manually discretizing the continoum into several discrete values. This case is particularly challenging for sweetpea because it is difficult to phrase sampling a continious distribution as a boolean formula; for more thought on how we could better support this see Future Work.

\subsection{Ordering Constraints}

Researchers must have some control over the ordering of stimuli to be able to test their hypothesis. For example, if you are testing whether the presence of a certain level effects the subject's reaction time, you need control over when that level occurs and how often it occurs in relation to other levels. More generally, you need to be able to constrain the presence or absense of relationships which you define over the levels. Since levels can be grouped into arbitrary sub-levels, you should more generally be able to specify constraints on relationships over the sub-levels.

TODO: about diagrams

One example of such a relationship is a \emph{transition} constraint, which specifies whether each level is followed by the same level (a repetition) or a different level (a switch). Another example is a \emph{congruence} constraint, which specifies whether the levels of different factors are, according to a user-specified metric, complementary or conflicting. A congruence constraint for the Stroop is whether the color of the ink and the text are the same (the word "red" in red ink) or not.

Another common relationship is a \emph{balancing} constraint. A pair of levels is balanced if each instance shows up the same number of times; a full crossing of all levels is a fully balanced experiment.

Constraints can also be defined in terms of other constraints. For instance, in the Stroop test one may want to balance the number of congruent and incongruent levels, or even balance the transitions between congruent and incongruent levels.

\subsection{Experimental Design and Balancing}

Experiments which include every possible combination of levels are \emph{fully crossed} designs. Fully crossings are desirable because they allow the researcher to test the full space of possible stimuli.

Sometimes, however, an experiment is either too large or too small. An experiment can be too large if it has too many elements in the full crossing because there are limits on how many tasks a subject can perform in a single session reliably. If an experiment is too large it can either be restated as a full crossing of only a subset of the factors (with the non-crossed factors being assigned at random, with uniform probability), or it can be divided across subjects or across experimental sessions. An experiment can be too small if the full crossing has too few stimuli to reliably draw conclusions. In this case, the experiment can either be multiple full crossings back-to-back, or the contents of multiple full crossings combined into a larger experimental block.



- sometimes its impossible to fully-counterweight and it'd be awesome if the tool could tell you if you were trying to do something impossible

- sometimes can fix impossible by weighted crossing

- sometimes can fix by "near balancing" or toss-away block, ie balancing transitions

- ultimate declarative would be just say "these are what I want to analyze, balance for me"

\subsection{Experimental Structure}
- Experimental structure (ie multiple blocks)

- sometimes want prologue / epilogue blocks

- sometimes need these to balance transitions

- sometimes have an experiment that consists of multiple experiments

- sometimes want to reason between subjects because space is so large or too small



\section{SweetPea Primitives}

- for all: how does it map onto the pysch and why is it amenable to SAT

- details about SAT encodings in the next section

\subsection{Factors and Levels}
- possibly nested lists; that is to say trees

\begin{lstlisting}
text      = ("text",      ["red", "blue"])

light_colors = ("light_colors", ["pink", "aqua"])
dark_colors = ("dark_colors", ["navy", "maroon"])
ink_color = ("ink_color", [light_colors, dark_colors])
\end{lstlisting}

- an experiment has one option for a level on at a time

- we can represent whether a level is on or not as a boolean variable, then have a boolean constraint that says that only one can be on at a time

- a nesting isn't represented in the boolean logic, it's just a reference to arbitraty groupings of levels that can be used in the relationships; can build a factor directly or from these groups. Q: what if overlapping level in multiple groupings? probably need to define it as a level then construct multiple references.

- don't currently support sampling factors that are cont distributions because it's challenging to translate that to discrete boolean SAT

\subsection{Derived Levels}
- how do we represent these relationships?

- because they all have to do with ordering, let's consider a "window". Windows have a width and a stride.

- example: transitions

- example: congruence

\begin{lstlisting}
ink_color = ("ink_color", ["red", "blue"])
text      = ("text",      ["red", "blue"])

repeat_level  = DerivedLevel("con", Transition(op.eq, [ink_color, ink_color]))
switch_level  = DerivedLevel("inc", Transition(op.ne, [ink_color, ink_color]))
transitionFactor = Factor("congruent?", [conLevel, incLevel])

congruenceFactor = Factor("congruent?", ["con", "inc"], WithinTrial(op.eq, [ink_color, text]))

\end{lstlisting}

- windows implicitly "select" and group levels.

- we can then define functions. they are allowed to depend on the state (on or off) of levels, and use this state to say whether or not *they* are "on". Example, congruence. In this way, they're defining new levels (since a level is just a thing that knows whether it's on or off) -- which is why they're derived factors.

- these should allow us to define things that skip elements, like the "bait" example

- why is this amenable to SAT? we've got discrete boolean elements whose state depends only upon the state of other boolean elements.

- an advantage is that Levels can have any [printable] type (can be strings, numbers, etc) and then you can build your derivation functions however you like based on those properties. maybe list an example with numbers.

- two options: you can either define a factor with a partition (levels are "where the func is true" and "where the func is false") or by defining and combining levels

\subsection{Experimental Design, Balacing and Experimental Structure}

- really straightforward. An experimental sequence is a list of experimental blocks. An experimental block is at the high level these derivations and at the low level linearized into a list of SAT that the runtime can execute. A design is literally which factors are visible and for balancing we currently only support full-crossings.

- we'll discuss how these are represented in SAT in the next section

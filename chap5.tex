%%% -*-LaTeX-*-

\chapter{SAT Encodings}

In this chapter we'll examine how the language forms we saw in the previous chapter are efficiently encoded as boolean formulas. A program in SweetPea is translated to a boolean formula in Conjunctive Normal Form (CNF), which is a canonicalization which is frequently used by SAT solvers and samplers. We generally use two techniques for efficient SAT encodings: we encode large "counting" constraints using a Tsietin transform, and user's derivation constraints more directly. After examining how a program is encoded, we'll also discuss how the runtime communicates with the sampler, and why the correctness guarantees are preserved.

\section{Conjunctive Normal Form (CNF)}

A boolean formula consists of boolean variables combined using boolean operators, such as AND, OR and NOT. There are many canonical forms for boolean formulas; the one that SAT solvers commonly use is Conjunctive Normal Form (CNF). CNF is an "and of ors". This means that CNF is built out of OR clauses, which are clauses in which the boolean OR operator is applied to a list of variables. A or B or (not C) or D is an example of an OR clause. CNF is then the AND operator applied to a list of OR clauses. (A or B) and (C or not D) is an example of a boolean formula in CNF.

SAT solvers typically process boolean formulas in CNF. This is partially because they are amenable to the search strategies that solvers commonly employ while searching for satisfying assignments, and partially because there is an efficient translation from a boolean formula in any form to the CNF canonical form.

More specifically, solvers typically process boolean formulas in the DIMACS CNF form. In the DIMACS convention, boolean variables are denoted by their index, and negation is denoted by a minus sign. This means that a formula like (A or B) and (C or not D) is represented as (1 or 2) and (3 or -4). This index based renaming is very convinient as a convention for generating fresh variable names-- you just need to increment the variable counter. Moreover, each or-clause is written on an individual line, and every term within the or-clause is written as an element of a list; each list is terminated with the number 0. Finally, each formula also has a header which clues the consumer to the number of variables and clauses in formula. The full DIMACS CNF specification of the example in this paragraph is:
p cnf 4 2
1, 2, 0
3, -4, 0

This specification is the langauge required to leverage the awesome power of SAT samplers and solvers, but it is clearly not amemable to being manually specified by human hands for anything but the most toy examples. That is why SweetPea provides a high-level domain-specific interface which compiles to these low-level specifications. An interesting aspect of the translation is ensuring that the encoding is efficeint: that is, polynomial in the number of number of variables and clauses with respect to the constraint size.

\section{Representing SweetPea Primitives in CNF}

Recall that experimental designs describe trials in terms of factors and levels, and the relationships between those trials in terms of windows, derivation functions and counting constraints. Here, let's see how all of those components are encoded into a boolean formula; in the next chapter we'll discuss trade-offs of some encoding decisions and more details.

\subsection{Representing Levels and Factors}

Levels correspond naturally to boolean variables; a factor has one level at a time selected and each level can exist in either a selected state or a non-selected state. Therefore, we allocate one variable for each level of each factor of each trial. TODO DIAGRAM. 

- as mentioned in the last chapter, levels correspond naturally to boolean values

- variables are index based (important for examples)

- keep track of : 1) variables which need assignemnts, 2) boolean formulas using those vars

- need additional constraint; one hot encoding, exactly one true at a time. literally represent as (a and not b) or (not a and b) -- this would be a bad choice if there were many levels but given the experimental size this is the best decision.

- walk through an example

- also need "sum" constraints. These also count up, but we expect these to be much bigger numbers, ie in the experiment w/ 7 factors w/ 2 levels, there are 64 of each level. So these we compile to "counting constraints". Basically these are linear inequality. We compile them to SAT efficeintly through the Tsietin transform (see next chapter for details).

- walk through an example

\subsection{Representing Derived Levels and Derivation Functions}

Internally, we pick out the levels, create new levels whose value depends on a boolean relationship of those levels. The relationship is then defined by a literal truth table:
- generate a truth table for the defined function by:
- each input is a factor
- then take all boolean combos and literally run it
- that generates a truth table
- encode that truth table in the logic by translating to CNF

- Work an example, for instance congruence.

\section{Communicating with the SAT-Sampler}

- block diagram of all runtime

- variables marked as "important" vs aux

- translate output to be human readable; easy to integrate with other environments


\section{Correctness Guarantees}

- cite guarantee from unigen

- postulate why this is preserved: TODO

%%% -*-LaTeX-*-

\chapter{SAT Encodings}

- chapter summary here

\section{Conjunctive Normal Form (CNF)}

A boolean formula consists of boolean variables combined using boolean operators, such as AND, OR and NOT. There are many canonical forms for boolean formulas; the one that SAT solvers commonly use is Conjunctive Normal Form (CNF). CNF is an "and of ors". This means that CNF is built out of OR clauses, which are clauses in which the boolean OR operator is applied to a list of variables. A or B or (not C) or D is an example of an OR clause. CNF is then the AND operator applied to a list of OR clauses. (A or B) and (C or not D) is an example of a boolean formula in CNF.

SAT solvers typically process boolean formulas in CNF. This is partially because they are amenable to common search strategies that solvers use in search of satisfying assignments, and partially because there is an efficient translation from a boolean formula in any form to the CNF canonical form.

More specifically, solvers typically process boolean formulas in the DIMACS CNF form. In the DIMACS convention, boolean variables are denoted by their index. This means that a formula like (A or B) and (C or not D) is represented as (1 or 2) and (3 or -4). This index based renaming is very convinient as a convention for generating fresh variable names-- you just need to increment the variable counter.

- variables are index based (important for examples)

- keep track of : 1) variables which need assignemnts, 2) boolean formulas using those vars

- CNF is standard because it makes search easy ; what is it

- can efficently (how efficeintly) translate into CNF

\section{Representing SweetPea Primitives in CNF}

- section summary here:

- mention counting constraints in two flavors

\subsection{Representing Levels and Factors}

- as mentioned in the last chapter, levels correspond naturally to boolean values

- need additional constraint; one hot encoding, exactly one true at a time. literally represent as (a and not b) or (not a and b) -- this would be a bad choice if there were many levels but given the experimental size this is the best decision.

- walk through an example

- also need "sum" constraints. These also count up, but we expect these to be much bigger numbers, ie in the experiment w/ 7 factors w/ 2 levels, there are 64 of each level. So these we compile to "counting constraints". Basically these are linear inequality. We compile them to SAT efficeintly through the Tsietin transform (see next chapter for details).

- walk through an example

\subsection{Representing Derived Levels and Derivation Functions}

Internally, we pick out the levels, create new levels whose value depends on a boolean relationship of those levels. The relationship is then defined by a literal truth table:
- generate a truth table for the defined function by:
- each input is a factor
- then take all boolean combos and literally run it
- that generates a truth table
- encode that truth table in the logic by translating to CNF

- Work an example, for instance congruence.

\section{Communicating with the SAT-Sampler}

- block diagram of all runtime

- variables marked as "important" vs aux

- translate output to be human readable; easy to integrate with other environments


\section{Correctness Guarantees}

- cite guarantee from unigen

- postulate why this is preserved: TODO

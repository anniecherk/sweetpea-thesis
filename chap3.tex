%%% -*-LaTeX-*-


\chapter{Related Work}

SweetPea is a computation tool for pyschologists. More specifically, it is a domain specific language, and even more specifically, it is a solver-aided language. SweetPea attempts to solve a computationally hard problem: producing a solution to a set of constraints, such that that solution is as likely as any other solution. To the best of our knowledge, SweetPea is the only system to address this specific problem, however there is a large body of work related to each of these concepts. Here we present previous work on computational tools for psychology, domain specific and solver aided languages, and on working in combinatorial search spaces.

\section{Psychology Toolboxes}

- psyScope \cite{cohen1993psyscope}

- psychoPy \cite{mathot2012opensesame}

- OpenSesame \cite{peirce2009generating}

\subsection{Reproducibility Crisis}

- TODO: surely something goes here

\section{Domain Specific Languages}

A domain specific language is a programming interface designed to express a specific set of problems, in contrast to a general programming language. There are so many domain specific languages, what do I even say here.

\subsection{Solver Aided Languages}

SweetPea is an interface to the SAT sampler Unigen. The benefit of Unigen is it provides strong statistical guarantees, but the drawback is that it only understands boolean formulas. To leverge the power of this tool

- rosette \cite{torlak2014lightweight}

- sketch: "Domain-Specific Symbolic Compilation"

- dafny maybe

- hyperkernel: co-designing a language and the verification


\section{Combinatorial Search Spaces}

Why does SweetPea need to use a SAT-sampler? Using a SAT-sampler is like bringing a nuke to a knife fight; if a more straight-forward solution was tractable, it would be much simpler, faster, and more maintainable to use a simple solution.

Recall that the goal is to find an ordering of trials which satisfies the constraints, and to return that valid ordering with uniform probability relative to all the other valid orderings. This means that our search space is the space of all possible orderings of the given set of trials (which may realistically consist of ~120 trials, corresponding to $120!$ orderings), and elements of this search space are specific orderings.

The first straight-forward solution is to try a random element in the search space, and see if that ordering satisfies the constraints. For realistic experiments, we found this approach to be intractable-- the set of solutions is sparce in the search space.

The other simpler solution is to generate all of the valid elements, and then choose uniformly among them. In practice, we also found this approach to be intractable. While the space of solutions was sparce in the search space, it was also far too large to exhaustively generate.

The simplest possible solution, and the one used in practice today by psychologists, is to generate the experimental sequence one trial at a time, backtracking when an assignment is made which violates the constraints. Unfortunantly this approach does not produce uniformly probable solutions. TODO diagram. Similarly, sampling methods like MCMC would also be able to tractably find solutions, but wouldn't provide any guarantee about their distribution.

For the experimental designs we want to support, we found that the methods mentioned above were either intractable or favored certain satisfying sequences over others. The search problem SweetPea addresses is NP hard, and our problem size is too large to use brute force despite the exponentially large space. Therefore, we compromised: SweetPea uses an approximate sampling method with statistical guarantees. By using an approximate sampling method we gain traction on the otherwise untractably large space, and by using the SAT sampler Unigen we maintain strong rigerous guarantees of the distribution of solutions.

\subsection{Boolean Satisfiability}

- SAT is a classic problem, NP-complete

- SAT solvers are really efficient solvers

- To specify something in SAT, you use variables and specify invariants

- the SAT solver finds an assignment that satisfies the invariants

- we use a SAT sampler which finds multiple assignments, and with guarnatees

- an alternative is using SMT constraints

- we compile to SAT because unigen is available; to use a different tool we could pretty easily swap out the backend

\cite{tseitin1983complexity}

\subsection{Uniform Sampling}

\cite{meel2016constrained}

- what problem is it solving? want uniform for coverage

- who else cares about this problem

- how is it solved: universal hash functions

- what alternatives exist
